/*
    Basler cameras provide chunk features. This means that the cameras can generate additional information about each image,
    e.g. frame counters, time stamps, and CRC checksums. The information is appended to the image data as data "chunks".
    This sample illustrates how to enable chunk features, how to grab images, and how to process the appended
    data. When the camera is in chunk mode, it transfers data blocks that are partitioned into chunks. The first
    chunk is always the image data. When chunk features are enabled, the image data chunk is followed by chunks
    containing the information generated by the chunk features.
*/

using System;
using System.Threading;
using Basler.Pylon;

namespace Grab_ChunkImage
{

    class Grab_ChunkImage
    {
        internal static void Main()
        {
            // The number of images to grab.
            const int c_countOfImagesToGrab = 10;

            // The exit code of the sample application.
            int exitCode = 0;

            try
            {
                // Create a camera object that selects the first camera device found.
                // More constructors are available for selecting a specific camera device.
                using (Camera camera = new Camera())
                {
                    // Print the model name of the camera.
                    Console.WriteLine("Using camera {0}.", camera.CameraInfo[CameraInfoKey.ModelName]);

                    // Set the acquisition mode to free running continuous acquisition when the camera is opened.
                    camera.CameraOpened += Configuration.AcquireContinuous;

                    // Open the connection to the camera device.
                    camera.Open();

                    // Enable the chunk mode.
                    if (!camera.Parameters[PLCamera.ChunkModeActive].TrySetValue(true))
                    {
                        throw new Exception("The camera doesn't support chunk features");
                    }

                    // Enable time stamp chunks.
                    camera.Parameters[PLCamera.ChunkSelector].SetValue(PLCamera.ChunkSelector.Timestamp);
                    camera.Parameters[PLCamera.ChunkEnable].SetValue(true);

                    // Enable frame counter chunk if possible.
                    if (camera.Parameters[PLCamera.ChunkSelector].TrySetValue(PLCamera.ChunkSelector.Framecounter))
                    {
                        camera.Parameters[PLCamera.ChunkEnable].SetValue(true);
                    }
                    // Enable generic counters if possible (USB camera devices).
                    else if (camera.Parameters[PLCamera.ChunkSelector].TrySetValue(PLCamera.ChunkSelector.CounterValue))
                    {
                        camera.Parameters[PLCamera.ChunkEnable].SetValue(true);
                        camera.Parameters[PLCamera.CounterSelector].SetValue(PLCamera.CounterSelector.Counter1);
                        camera.Parameters[PLCamera.CounterEventSource].SetValue(PLCamera.CounterEventSource.FrameStart);
                    }

                    // Enable CRC checksum chunks.
                    camera.Parameters[PLCamera.ChunkSelector].SetValue(PLCamera.ChunkSelector.PayloadCRC16);
                    camera.Parameters[PLCamera.ChunkEnable].SetValue(true);


                    // Start grabbing c_countOfImagesToGrab images.
                    camera.StreamGrabber.Start(c_countOfImagesToGrab);

                    // camera.StreamGrabber.Stop() is called automatically by the RetrieveResult() method
                    // when c_countOfImagesToGrab images have been retrieved.
                    while (camera.StreamGrabber.IsGrabbing)
                    {
                        // Wait for an image and then retrieve it. A timeout of 5000 ms is used.
                        IGrabResult grabResult = camera.StreamGrabber.RetrieveResult(5000, TimeoutHandling.ThrowException);
                        using (grabResult)
                        {
                            // Image grabbed successfully?
                            if (grabResult.GrabSucceeded)
                            {

                                // Display the grabbed image.
                                ImageWindow.DisplayImage(0, grabResult);

                                // Check to see if a buffer containing chunk data has been received.
                                if (PayloadType.ChunkData != grabResult.PayloadTypeValue)
                                {
                                    throw new Exception("Unexpected payload type received.");
                                }

                                // Because we have enabled the CRC Checksum feature, we can check
                                // the integrity of the buffer.
                                // Note: Enabling the CRC Checksum feature is not a prerequisite for using chunks.
                                // Chunks can also be handled when the CRC Checksum feature is disabled.
                                if (grabResult.HasCRC && grabResult.CheckCRC() == false)
                                {
                                    throw new Exception("Image was damaged!");
                                }

                                // Access the chunk data attached to the result.
                                // Before accessing the chunk data, you should check to see
                                // if the chunk is readable. If it is readable, the buffer
                                // contains the requested chunk data.
                                if (grabResult.ChunkData[PLChunkData.ChunkTimestamp].IsReadable)
                                {
                                    Console.WriteLine("ChunkData: TimeStamp = {0}", grabResult.ChunkData[PLChunkData.ChunkTimestamp]);
                                }
                                else
                                {
                                    Console.WriteLine("ChunkData: No TimeStamp");
                                }

                                // Print the frame counter value.
                                if (grabResult.ChunkData[PLChunkData.ChunkFramecounter].IsReadable)
                                {
                                    Console.WriteLine("ChunkData: FrameCounter = {0}", grabResult.ChunkData[PLChunkData.ChunkFramecounter]);
                                }
                                // Print the generic counter value (USB camera devices).
                                else if (grabResult.ChunkData[PLChunkData.ChunkCounterSelector].TrySetValue(PLChunkData.ChunkCounterSelector.Counter1)
                                      && grabResult.ChunkData[PLChunkData.ChunkCounterValue].IsReadable
                                    )
                                {
                                    Console.WriteLine("ChunkData: FrameCounter = {0}", grabResult.ChunkData[PLChunkData.ChunkCounterValue]);
                                }

                                Console.WriteLine("");
                            }
                            else
                            {
                                Console.WriteLine("Error: {0} {1}", grabResult.ErrorCode, grabResult.ErrorDescription);
                            }
                        }
                    }
                    camera.Parameters[PLCamera.ChunkModeActive].SetValue(false);
                }
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Exception: {0}", e.Message);
                exitCode = 1;
            }
            finally
            {
                // Comment the following two lines to disable waiting on exit.
                Console.Error.WriteLine("\nPress enter to exit.");
                Console.ReadLine();
            }

            Environment.Exit(exitCode);
        }
    }
}

